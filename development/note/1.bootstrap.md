# xv6启动过程
在README中有如下的描述：

> BUILDING AND RUNNING XV6
> 
> To build xv6 on an x86 ELF machine (like Linux or FreeBSD), run
> "make". On non-x86 or non-ELF machines (like OS X, even on x86), you
> will need to install a cross-compiler gcc suite capable of producing
> x86 ELF binaries (see https://pdos.csail.mit.edu/6.828/).
> Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
> simulator and run "make qemu".

我们选择使用qemu来调试，看下`make qemu`的参数，发现需要信赖fs.img与xv6.img
```Makefile
QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
```

fs.img先不用理会，xv6.img信赖bootblock与kernel。

```Makefile
xv6.img: bootblock kernel
	dd if=/dev/zero of=xv6.img count=10000
	dd if=bootblock of=xv6.img conv=notrunc
	dd if=kernel of=xv6.img seek=1 conv=notrunc
```

```Makefile
bootblock: bootasm.S bootmain.c
	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
	$(OBJDUMP) -S bootblock.o > bootblock.asm
	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
	./sign.pl bootblock
```

bootblock信赖bootasm.S与bootmain.c两个文件，看名字，应该是引导相关的。

# x86启动 此以需要更详细的资料说明
看具体的代码前先说说 x86 架构开机引导的相关知识。从给 x86 通电的一刻开始，CPU 执行的第一段指令是 BIOS 固化在 ROM 上的代码，这个过程是硬件定死的规矩，就是这样。

而 BIOS 在硬件自检完成后（你会听到“滴”的一声）会根据你在 BIOS 里设置的启动顺序（硬盘、光驱、USB）读取每个引导设备的第一个扇区 512字节的内容，并判断这段内容的最后 2 字节是否为 0xAA55，如果是说明这个设备是可引导的，于是就将这 512 字节的内容放到内存的 0x7C00 位置，然后告诉 CPU 去执行这个位置的指令。这个过程同样是硬件定死的规矩，就是这样。

有了上面的介绍我们再回到 xv6 如果你看一下编译生成的 bootblock 二进制文件，你会惊喜的发现它的文件大小刚好是 512 字节。用十六进制编辑器（我在 Mac OSX 下用的是 0xED 这个软件）打开 bootblock 这个二进制文件，你又会发现这个 512 字节的文件的最后两字节正好是 0xAA55。

再回过头看上面 Makefile 中 xv6.img 生成条件的代码中也可以看出 xv6.img 就是通过 dd 命令讲编译好的 bootblock 和 kernel 拼接而成，这也再一次印证了 bootblock 是负责引导逻辑的结论。

有了这个结论，我们可以开始“放心大胆”的开始看 bootasm.S 这个汇编源文件的代码了。

# bootasm.S

在Makefile bootblock中有下面的一句编译指令，将代码段加载到0x7C00处，代码从start开始执行，所以bootasm.S入口就是start。
```Makefile
$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
```

先看前面几行代码：
```x86asm
# 指定使用16位模式下执行代码，此时寻址能力只有1MB。
.code16                       # Assemble for 16-bit mode
# 指定start为入口函数
.globl start

start:
  # 为了保证引导代码顺利执行，关闭中断响应，此时计算机不再响应任何中断事件
  cli                         # BIOS enabled interrupts; disable

  # 将AX, DS, ES, SS寄存器值初始化为0
  # Zero data segment registers DS, ES, and SS.

  # xorw为异或（互斥）操作符，两个位的值相同，结果为0，否则为1，并将结果存入暂存器
  # 所以此时ax的值为0
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -> Data Segment
  movw    %ax,%es             # -> Extra Segment
  movw    %ax,%ss             # -> Stack Segment
```

# 打开 A20 gate
http://kernelx.weebly.com/a20-address-line.html

当 IBM PC AT 系统推出时，新的英特尔 286 处理器与旧的 x86 处理器不兼容。旧的 x86 微处理器（英特尔 8086）的地址总线为 20 位，总共可以访问 1 兆字节的内存。 Intel 386 及更高版本的地址总线高达 32 位，允许 4 GB 的内存。但旧的 8086 处理器没有这么大的地址总线。为了与旧处理器兼容并解决问题，Intel 引入了逻辑或门 在可以启用或禁用的地址总线的 20 位。因此，为了与旧处理器和程序兼容，A20 在启动时被禁用。

注意：BIOS 实际上启用 A20 来计算和测试可用内存，然后在再次启动之前禁用它以保持与旧处理器的兼容。

A20 门是一个电子或门，可以被禁用和启用，位于地址总线的第 20 位。它通过键盘控制器的 P21 线连接，使键盘控制器可以启用或禁用 A20 门。

在现代，需要的内存不仅仅是 1MB。应用程序、游戏等需要大量内存。即使是操作系统内核也可能吃掉整个 1MB。所以它几乎不可能运行 1MB 内存中的现代程序。看起来 A20 是操作系统良好功能的重要特征。

要启用 A20 门，有 3 种方法，或者您可以使用高级内存管理器（例如 HIMEM.sys）或使用引导加载程序（例如 GRUB）跳过此步骤（GRUB 将在启用 A20 的情况下为您设置保护模式）

启用 A20 Gate 的 3 种方法是
+ 键盘控制器
+ BIOS功能
+ 系统端口

## 键盘控制器
是启用A20 Gate最常见的方法。键盘微控制器提供禁用和启用A20的功能。在启用A20之前我们需要禁用中断以防止我们的内核被弄乱。端口0x64用于发送命令字节。

命令字节和端口
+ 0xDD 启用 A20 地址线
+ 0xDF 禁用 A20 地址线

通过0x64端口向8042微控制器（即intel 8042芯片，位于主板上）发送命令(0x64 Port of the 8042 micro-controller for sending commands)

```x86asm
EnableA20_KB:
cli                ;Disables interrupts
push ax            ;Saves AX
mov al, 0xdd       ;Look at the command list 
out 0x64, al       ;Command Register 
pop ax             ;Restore's AX
sti                ;Enables interrupts
ret 
```

# bootasm.S中启用A20
```x86asm
# 第一步是向 804x 键盘控制器的 0x64 端口发送命令。
seta20.1:
  # inb
  # 读取0x64端口数据（8-bit），写入al寄存器
  # 此时读取的是8042芯片的状态寄存器，其数据格式如下： 
  # https://blog.csdn.net/hbuxiaofei/article/details/116274989
  # Bit7: PARITY-EVEN(P_E): 从键盘获得的数据奇偶校验错误
  # Bit6: RCV-TMOUT(R_T): 接收超时，置1
  # Bit5: TRANS_TMOUT(T_T): 发送超时，置1
  # Bit4: KYBD_INH(K_I): 为1，键盘没有被禁止。为0，键盘被禁止。
  # Bit3: CMD_DATA(C_D): 为1，输入缓冲器中的内容为命令，为0，输入缓冲器中的内容为数据。
  # Bit2: SYS_FLAG(S_F): 系统标志，加电启动置0，自检通过后置1
  # Bit1: INPUT_BUF_FULL(I_B_F): 输入缓冲器满置1，i8042 取走后置0
  # BitO: OUT_BUF_FULL(O_B_F): 输出缓冲器满置1，CPU读取后置0
  inb     $0x64,%al               # Wait for not busy

  # testb
  # 将两个操作数进行按位AND,设结果是TEMP
  # SF = 将结果的最高位赋给SF标志位，例如结果最高位是1，SF就是1
  # 看TEMP是不是0，如果TEMP是0，ZF位置1；如果TEMP不是0，ZF位置0
  # PF = 将TEMP的低8位，从第0位开始，逐位取同或。也就是第0位与第1位的同或结果，去和第2位同或，结果再去和第3位同或…直到和第7位同或。PF位是奇偶校验位，如果结果低8位中1的个数是偶数，PF=1；否则PF=0
  # CF位置0
  # OF位置0
  testb   $0x2,%al

  # jnz的执行条件为ZF=0，即8042芯片中有输入内容
  jnz     seta20.1

  # 向该端口执行 out 写操作时，代表向键盘控制器发送命令，发送 0xd1 代
  # 表要向键盘控制器的 P2 端口写入数据，要写入的数据通过 0x60 端口传入
  movb    $0xd1,%al               # 0xd1 -> port 0x64
  outb    %al,$0x64

# 第二步就是向键盘控制器的 P2 端口写数据了。写数据的方法是把数据通过键盘控制器的 0x60 端口写进去。写入的数据是 0xdf，因为 A20 gate 就包含在键盘控制器的 P2 端口中，随着 0xdf 的写入，A20 gate 就被打开了。
seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -> port 0x60
  outb    %al,$0x60
```

# 准备GDT
加载[GDTR](http://petpwiuta.github.io/2020/05/09/%E8%BF%9B%E5%85%A532%E4%BD%8D%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%8A%A0%E8%BD%BDGDTR)

GDTR有48位，其中32位用来存放在内存中的起始地址，16位用来存放表的长度。

CPU可以处理两种尺寸的数据，即字(word)和字节(byte)，CPU和内存之间的数据传送单位通常是一个字长。

我们知道，1byte = 8bit，那么字长又是多少呢？其实字长通常跟CPU的位数相同。例如：64位CPU字长就是64位，即1word = 8byte，寄存器大小也是64位。但是也有个别情况，比如 Intel 80386CPU是32位的，但字长却是16位，即1word = 2byte，这是为了向后兼容80286CPU(16位)。

看下在xv6中如何准备GDT的
```x86asm
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg
```

在上述代码中，使用了定义在ash.h中几个宏，展开后如下：
```x86asm
gdt:
  .word 0, 0;
  .byte 0, 0, 0, 0                             # 空
  .word 0xffff, 0x0000;
  .byte 0x00, 0x9a, 0xcf, 0x00                 # 代码段
  .word 0xffff, 0x0000;
  .byte 0x00, 0x92, 0xcf, 0x00                 # 数据段
```

# 进入保护模式
CPU 单独为我们准备了一个寄存器叫做 GDTR 用来保存我们 GDT 在内存中的位置和我们 GDT 的长度。GDTR 寄存器一共 48 位，其中高 32 位用来存储我们的 GDT 在内存中的位置，其余的低 16 位用来存我们的 GDT 有多少个段描述符。 16 位最大可以表示 65536 个数，这里我们把单位换成字节，而一个段描述符是 8 字节，所以 GDT 最多可以有 8192 个段描述符。不仅 CPU 用了一个单独的寄存器 GDTR 来存储我们的 GDT，而且还专门提供了一个指令用来让我们把 GDT 的地址和长度传给 GDTR 寄存器，来看 xv6 的代码：

```x86asm
lgdt   gdtdesc
...
gdtdesc:
  .word   (gdtdesc - gdt - 1)             # 16 位的 gdt 大小sizeof(gdt) - 1
  .long   gdt                             # 32 位的 gdt 所在物理地址
```

如同 A20 gate 这个开关负责打开 1MB 以上内存寻址一样，想要进入“保护模式”我们也需要打开一个开关，这个开关叫“控制寄存器”，x86 的控制寄存器一共有 4 个分别是 CR0、CR1、CR2、CR3，而控制进入“保护模式”的开关在 CR0 上，这四个寄存器都是 32 位的，我们看一下 CR0 上和保护模式有关的位

```
|31|--------30~1--------| 0|
----------------------------
|PG|--------------------|PE|
```
+ PG 为 0 时代表只使用分段式，不使用分页式。为 1 是启用分页式
+ PE 为 0 时代表关闭保护模式，运行在实模式下。为 1 则开启保护模式

xv6 打开保护模式的代码：
```x86asm
movl    %cr0, %eax
orl     $CR0_PE, %eax
movl    %eax, %cr0
```

因为我们无法直接操作 CR0，所以我们首先要用一个通用寄存器来保存当前 CR0 寄存器的值，这里第一行就是用通用寄存器 eax 来保存 cr0 寄存器的值；然后 CR0_PE 这个宏的定义在 mmu.h 文件中，是个数值 0x00000001，将这个数值与 eax 中的 cr0 寄存器的值做“或”运算后，就保证将 cr0 的第 0 位设置成了 1 即 PE = 1 保证打开了保护模式的开关。而 cr0 的第 31 位 PG = 0 表示我们只使用分段式，不使用分页，这时再将新的计算后的 eax 寄存器中的值写回到 cr0 寄存器中就完成了到保护模式的切换。

# 准备迎接 .code32
到这里我们关于 xv6 从实模式到保护模式的讲解就接近尾声了。我们已经进入到保护模式了，接下来可以将代码彻底以 32 位的保护模式来运行了。所以这时我们的 xv6 也要准备跳转了，再来看一行代码：

```x86asm
ljmp  $(SEG_KCODE<<3) $start32
```

这是一个跳转语句，通知 CPU 跳转到指定位置继续执行指令。 xv6 在这时就准备跳转到用 C 写成的代码处去继续运行了。这个跳转语句的两个参数就是我们之前一直再讲的典型的“基地址” + “偏移量”的方式告诉 CPU 要跳转到内存的什么位置去继续执行指令。

在分段式保护模式下“段基址”（基地址）不再是内存地址，而是 GDT 表的下标。上面我们也说过 GDT 表最大可以有 8192 个表项（段描述符），2^13 = 8192，所以保存着“段基址”的 16 位段寄存器只需要其中的 13 位就可以表示一个 GDT 表的下标，其余的 3 位可用作他用。

按照这个思路我们看看这个 $(SEG_KCODE<<3) 生成的“段基址”是什么？SEG_KCODE 是个宏定义，具体的定义在 mmu.h 文件中，我们翻译过来就是 $(1<<3)，再将它运算出来得到：

```
15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
-------------------------------------------------------------
0	0	0	0	0	0	0	0	0	0	0	0	1	0	0	0
```

这里这个 16 位的“段基址”的高 13 位代表 GDT 表的下标（学名应该叫“段选择子”），这里高 13 位刚好是 1，而我们的 GDT 里下标位 1 的内存段正好是我们的“代码段”，而“代码段”我们在 GDT 的“段描述符”中设置了它的其实内存地址是 0x00000000 ，内存段长度是 0xfffff，这是完整的 4GB 内存。

所以这里的跳转语句选择了“代码段”，由于“代码段”的起始内存地址是 0x00000000 ，长度是完整的 4GB，所以后面的“偏移量”仍然相当于是实际的内存地址，所以这里“偏移量”直接用了 $start32，也就是 start32 直接对应的代码位置。通过这个跳转实际上 CPU 就会跳转到 bootasm.S 文件的 start32 标识符处继续执行了。

